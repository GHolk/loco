#!/bin/bash

## chain command
mcd() { 
    mkdir $@
    cd $1
}

cls() {
    cd $1
    ls
}

err() {
    echo "$@" >&2
}

gvfs() {
    gvfs-$*
}

## change and execute command
big5() {
    luit -encoding big5 "$@"
}
value() {
    local exit_state
    case "$1" in
        -q )
            shift
            quiet "$@"
            ;;
        -Q )
            shift
            quiet -Q "$@"
            ;;
        * )
            "$@"
            ;;
    esac
    exit_state=$?
    echo $exit_state
    return $exit_state
}
quiet() {
    if [ "$1" = -Q ]
    then
        shift
        "$@" >/dev/null 2>&1
    else
        "$@" >/dev/null
    fi
}
as_return() {
    return $(($1 == 0))
}
set_if_empty() {
    local name value
    name=$1
    value="$2"
    if eval [ -z \"\$$name\" ]
    then
        eval $name='"$value"'
        return 0
    else
        return 1
    fi
}

cutdf() {
    delimeter="$1"
    field="$2"
    shift
    shift
    cut -d "$delimeter" -f "$field" "$@"
}

# fc for script file
fx() {
    local command=$1
    history -s fx $command

    local output_script
    if [ -f $command ]
    then
        output_script="sed -e 1i( -e \$a) $command"
    else
        case `type -t $command` in
            file)
                # # check file is not binary
                # if file --mime --dereference $command_path \
                #     | fgrep --quiet --invert-match charset=binary
                output_script="sed -e 1i( -e \$a) `type -P $command`"
                ;;
            "function")
                output_script="declare -f $command"
                ;;
            "alias")
                output_script="alias $command"
                ;;
            *)
                err not editing support command type: `type -t $command`
                return 1
        esac
    fi
    local command_content=$($output_script | vipe)
    history -s "$command_content"
    eval "$command_content"
}
