#!/bin/bash

## chain command
mcd() { 
    mkdir $@
    cd $1
}

cls() {
    cd $1
    ls
}

err() {
    echo "$@" >&2
}

gvfs() {
    gvfs-$*
}

## change and execute command
big5() {
    luit -encoding big5 "$@"
}
value() {
    local exit_state
    case "$1" in
        -q )
            shift
            quiet "$@"
            ;;
        -Q )
            shift
            quiet -Q "$@"
            ;;
        * )
            "$@"
            ;;
    esac
    exit_state=$?
    echo $exit_state
    return $exit_state
}
quiet() {
    if [ "$1" = -Q ]
    then
        shift
        "$@" >/dev/null 2>&1
    else
        "$@" >/dev/null
    fi
}
as_return() {
    return $(($1 == 0))
}
set_if_empty() {
    local name value
    name=$1
    value="$2"
    if eval [ -z \"\$$name\" ]
    then
        eval $name='"$value"'
        return 0
    else
        return 1
    fi
}

cutdf() {
    delimeter="$1"
    field="$2"
    shift
    shift
    cut -d "$delimeter" -f "$field" "$@"
}

# fc for script file
fx() {
    local command=$1 command_content
    history -s fx $command
    case `type -t $command` in
        file)
            local command_path=`type -P $command`
            # # check file is not binary
            # if file --mime --dereference $command_path \
            #     | fgrep --quiet --invert-match charset=binary
            command_content=$(
                vipe < $command_path \
                 | sed -e '1i(' -e '$a)'
            )
            ;;
        "function")
            command_content=$(declare -f $command | vipe)
            ;;
        "alias")
            command_content=$(alias $command | vipe)
            ;;
        *)
            err not editing support command type
            return 1
    esac
    
    history -s "$command_content"
    eval "$command_content"
}
